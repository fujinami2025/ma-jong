<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8" />
  <title>2äººå¯¾æˆ¦éº»é›€ï¼ˆä»®ï¼‰</title>
  <style>
    html,
    body {
      height: 100%;
      margin: 0;
      min-width: 400px;
      min-height: 300px;
    }

    body {
      margin: 0;
      font-family: sans-serif;
      height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: flex-end;
      align-items: center;
    }

    #start,
    #status {
      text-align: center;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      flex-direction: column;
    }

    #game {
      flex: 1;
      width: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding-bottom: 140px;
      box-sizing: border-box;
    }

    #discard-container {
      width: 40vw;
      height: 40vw;
      background: rgba(200, 200, 200, 0.3);
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);

      display: flex;
      flex-direction: column;
      justify-content: space-between;
      padding: 10px;
      box-sizing: border-box;
      border-radius: 8px;
    }

    #opponent-discards {
      transform: rotate(180deg);
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      margin: 6px 0;
    }

    #my-discards {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      margin: 6px 0;
    }

    #hand-display {
      position: fixed;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      background-color: #fff;
      padding: 8px;
      border-top: 1px solid #ccc;
      z-index: 10;
    }

    .tile {
      /*ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚µã‚¤ã‚ºã«åˆã‚ã›ã‚‹*/
      width: 5vw;
      margin: 2px;
      cursor: pointer;
    }

    #score-container {
      width: 20vw;
      height: 20vw;
      background: rgba(22, 115, 255, 0.9);
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      padding: 10px;
      color: rgb(246, 255, 0);
      font-weight: bold;
      box-sizing: border-box;
      border-radius: 8px;
    }

    #score-top {
      text-align: center;
      transform: rotate(180deg);
      font-size: 2rem;
    }

    #score-bottom {
      text-align: center;
      font-size: 2rem;
    }
  </style>
</head>

<body>
  <div id="status">ã‚µãƒ¼ãƒãƒ¼ã«æ¥ç¶šä¸­...</div>

  <div id="start" style="display: none;">
    <h2>å¯¾æˆ¦ã‚¹ã‚¿ãƒ¼ãƒˆï¼</h2>
    <p>ã‚ãªãŸã¯ <span id="player"></span> ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã§ã™ã€‚</p>
  </div>

  <div id="game" style="display: none;">
    <p>ãƒ«ãƒ¼ãƒ ID: <span id="room"></span></p>

    <div id="discard-container">
      <div id="opponent-discards" style="margin-bottom: 10px;"></div>
      <div id="my-discards" style="margin-bottom: 10px;"></div>
    </div>

    <div id="score-container">
      <div id="score-top"><span id="score-0">25000</span></div>
      <div id="score-bottom"><span id="score-1">25000</span></div>
    </div>
    <div id="hand-display"></div>
    <button id="ron-button" style="display:none; margin-top:10px;">ãƒ­ãƒ³</button>
    <button id="skip-button" style="display:none; margin-top:10px;">ã‚¹ã‚­ãƒƒãƒ—</button>
    <button id="tsumo-button" style="display:none; margin-top:10px;">ãƒ„ãƒ¢</button>
    <button id="tsumoskip-button" style="display:none;">ã‚¹ã‚­ãƒƒãƒ—</button>
    <button id="riichi-button" style="display:none; margin-top:10px;">ãƒªãƒ¼ãƒ</button>
    <button id="cancel-riichi-button" style="display:none; margin-top:10px;">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
  </div>
  <div id="result-modal"
    style="display:none; position: fixed; top: 0; left: 0; width:100vw; height:100vh; background-color: rgba(0,0,0,0.5); z-index: 1000; align-items: center; justify-content: center;">
    <div style="background: white; padding: 20px; border-radius: 10px; max-width: 90%; text-align: center;">
      <p id="result-message" style="white-space: pre-line; font-size: 1.2em;"></p>
      <button id="result-ok">OK</button>
    </div>
  </div>
  
  <script>
    const statusDiv = document.getElementById('status');
    const startDiv = document.getElementById('start');
    const gameDiv = document.getElementById('game');
    const playerSpan = document.getElementById('player');
    const roomSpan = document.getElementById('room');
    const handDiv = document.getElementById('hand-display');
    const opponentDiscards = document.getElementById('opponent-discards');
    const myDiscards = document.getElementById('my-discards');
    const ronButton = document.getElementById('ron-button');
    const skipButton = document.getElementById('skip-button');
    const tsumoButton = document.getElementById('tsumo-button');
    const tsumoskipButton = document.getElementById("tsumoskip-button");
    const riichiButton = document.getElementById('riichi-button');
    const canselButton = document.getElementById('cancel-riichi-button');

    let myPlayerIndex = null;
    let myRoomId = null;
    let canDiscard = false;
    let ronPendingPai = null;
    let skipRequested = false;
    let isRiichi = false;
    let reached = false;
    let tingpaiSet = new Set();
    let currentHandString = '';
    let tingpaiList = [];
    let neverMyReach = true;
    let neverElseReach = true;

    const protocol = location.protocol === 'https:' ? 'wss' : 'ws';

    const ws = new WebSocket(`${protocol}://${location.host}/ws`);

    ws.onopen = () => {
      statusDiv.textContent = 'å¾…æ©Ÿä¸­â€¦ ä»–ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’å¾…ã£ã¦ã„ã¾ã™ã€‚';
    };

    ws.onmessage = (event) => {
      const data = JSON.parse(event.data);

      // å—ä¿¡ï¼šãƒªãƒ¼ãƒå¯èƒ½ç‰Œãƒªã‚¹ãƒˆ
      if (data.type === 'riichiCheck' && data.playerIndex === myPlayerIndex && !isRiichi) {
        tingpaiList = data.tingpaiList;    // [0,4,8,â€¦]
        console.log(tingpaiList);
        riichiButton.style.display = 'inline-block';
      }

      if (data.type === 'start') {
        // ğŸ” ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆçŠ¶æ…‹ãƒªã‚»ãƒƒãƒˆ
        canDiscard = false;
        ronPendingPai = null;
        skipRequested = false;
        isRiichi = false;
        reached = false;
        tingpaiSet = new Set();
        currentHandString = '';
        tingpaiList = [];
        neverMyReach = true;
        neverElseReach = true;
        myDiscards.innerHTML = '';
        opponentDiscards.innerHTML = '';
        // âœ… å¿…è¦ã«å¿œã˜ã¦UIãƒªã‚»ãƒƒãƒˆå‡¦ç†ã‚‚ã“ã“ã§è¿½åŠ 
        tsumoButton.style.display = 'none';
        ronButton.style.display = 'none';
        riichiButton.style.display = 'none';
        skipButton.style.display = 'none';

        statusDiv.style.display = 'none';
        startDiv.style.display = 'block';
        setTimeout(() => {
          startDiv.style.display = "none";
          gameDiv.style.display = "block";
        }, 2000); // 2000ms = 2ç§’
        myPlayerIndex = data.playerIndex;
        myRoomId = data.roomId;
        playerSpan.textContent = myPlayerIndex;
        roomSpan.textContent = myRoomId;

        currentHandString = data.handString || '';
        if (data.handString) showHandFromShoupaiString(data.handString);
      }

      if (data.type === 'tsumo') {
        if (data.playerIndex === myPlayerIndex) {
          currentHandString = data.handString || currentHandString;
          if (data.handString) showHandFromShoupaiString(data.handString);
          canDiscard = true;
        }
        if (data.aitenoRiichi) {//ç›¸æ‰‹ã®ãƒªãƒ¼ãƒæƒ…å ±
          console.log("ç›¸æ‰‹ãŒãƒªãƒ¼ãƒã—ã¾ã—ãŸ");
        }
      }

      if (data.type === 'dahai') {
        if (data.playerIndex == myPlayerIndex) {
          if (neverMyReach && data.isRiichi) {
            neverMyReach = false;
            showMyDiscardedTile(data.pai, data.isRiichi);
          } else {
            showMyDiscardedTile(data.pai);
          }
        } else {
          if (neverElseReach && data.isRiichi) {
            neverElseReach = false;
            showOpponentDiscardedTile(data.pai, data.isRiichi);
          } else {
            showOpponentDiscardedTile(data.pai);
          }
        }
      }

      if (data.type === 'ronCheck') {
        // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ãƒ­ãƒ³ã™ã‚‹ã‹ã©ã†ã‹é¸ã°ã›ã‚‹
        ronPendingPai = data.pai;
        showRonSkipButtons();
      }

      if (data.type === 'ron') {
        hideRonSkipButtons();

        const ronPai = convertMPSZToPaiIndex(data.pai);
        const point = data.huleDetail?.point ?? '???';
        const yakuList = Array.isArray(data.huleDetail?.yaku) ? data.huleDetail.yaku.join(', ') : 'å½¹ä¸æ˜';

        if (data.winner === myPlayerIndex) {
          showResultModal(
            `ğŸ‰ ã‚ãªãŸãŒãƒ­ãƒ³ã—ã¾ã—ãŸï¼\nç²å¾—ç‰Œ: ${ronPai}\nç‚¹æ•°: ${point}ç‚¹\nå½¹: ${yakuList}`,
            () => {
              // OKå¾Œã®å‡¦ç†ï¼ˆä¾‹ï¼šæ¬¡å±€ã®é–‹å§‹ãªã©ï¼‰
            }
          );
        } else {
          const handStr = Array.isArray(data.winnerHand)
            ? data.winnerHand.map(idx => convertIndexToMPSZ(idx)).join(' ')
            : '';
          showResultModal(
            `ç›¸æ‰‹ãŒãƒ­ãƒ³ã—ã¾ã—ãŸã€‚\næ”¾éŠƒç‰Œ: ${ronPai}\nç‚¹æ•°: -${point}ç‚¹\nå½¹: ${yakuList}\nç›¸æ‰‹ã®æ‰‹ç‰Œ: ${handStr}`,
            () => {
              // OKå¾Œã®å‡¦ç†ï¼ˆå¿…è¦ã«å¿œã˜ã¦ï¼‰
            }
          );
        }

        // ã‚¹ã‚³ã‚¢æ›´æ–°ï¼ˆã‚ã‚Œã°ï¼‰
        if (Array.isArray(data.newScores)) {
          updateScoreDisplay(data.newScores); // â† è‡ªä½œé–¢æ•°ã§ã‚¹ã‚³ã‚¢è¡¨ç¤ºã‚’æ›´æ–°ã™ã‚‹ã‚ˆã†ã«ã™ã‚‹
        }
      }


      if (data.type === 'tsumoCheck') {
        tsumoButton.style.display = 'inline-block';
        tsumoskipButton.style.display = 'inline-block';
        canDiscard = false; // ã¾ã æ¨ã¦ã‚‰ã‚Œãªã„ï¼ˆåˆ¤å®šä¸­ï¼‰
      }

      if (data.type === 'tsumoResult') {
        // ãƒœã‚¿ãƒ³éè¡¨ç¤ºï¼ˆå¿µã®ãŸã‚ï¼‰
        tsumoButton.style.display = 'none';
        ronButton.style.display = 'none';
        skipButton.style.display = 'none';

        const winner = data.winner;
        const loser = data.loser;
        const point = data.huleDetail?.point ?? '???';
        const yakuList = Array.isArray(data.huleDetail?.yaku)
          ? data.huleDetail.yaku.join(', ')
          : 'å½¹ä¸æ˜';
        if (winner === myPlayerIndex) {
          showResultModal(
            `ğŸ‰ ãƒ„ãƒ¢ã‚ãŒã‚Šï¼\nç‚¹æ•°: +${point}\nå½¹: ${yakuList}`,
            () => {
              // OKãƒœã‚¿ãƒ³ãŒæŠ¼ã•ã‚ŒãŸå¾Œã«ã‚„ã‚‹å‡¦ç†ï¼ˆå¿…è¦ã«å¿œã˜ã¦è¿½åŠ ï¼‰
            }
          );
        } else {
          const handStr = Array.isArray(data.winnerHand)
            ? data.winnerHand.map(idx => convertIndexToMPSZ(idx)).join(' ')
            : '';
          showResultModal(
            `ç›¸æ‰‹ãŒãƒ„ãƒ¢å’Œäº†ã—ã¾ã—ãŸã€‚\nç‚¹æ•°: -${point}ç‚¹\nå½¹: ${yakuList}\nç›¸æ‰‹ã®æ‰‹ç‰Œ: ${handStr}`,
            () => {
              // OKå¾Œã«è¡Œã†å‡¦ç†ï¼ˆä¾‹ï¼šæ‰‹ç‰ŒåˆæœŸåŒ–ã€ã‚¹ã‚³ã‚¢æ›´æ–°å¾Œã®ã‚¢ãƒ‹ãƒ¡ç­‰ï¼‰
            }
          );
        }

        // ã‚¹ã‚³ã‚¢è¡¨ç¤ºã‚’æ›´æ–°
        if (Array.isArray(data.newScores)) {
          updateScoreDisplay(data.newScores);
        }
      }

      if (data.type === 'waiting') {
        statusDiv.textContent = `å¾…æ©Ÿä¸­â€¦ ç¾åœ¨ ${data.count} äººãŒå¾…æ©Ÿã—ã¦ã„ã¾ã™ã€‚`;
      }
    };

    function showRonSkipButtons() {
      ronButton.style.display = 'inline-block';
      skipButton.style.display = 'inline-block';
    }

    function hideRonSkipButtons() {
      ronButton.style.display = 'none';
      skipButton.style.display = 'none';
    }

    function updateTileInteractivity() {
      console.log('å‹•ã„ã¦ã‚‹ã‚ˆãƒ¼');
      document.querySelectorAll('.tile').forEach(img => {
        const index = parseInt(img.dataset.index);
        if (reached) {
          // ãƒªãƒ¼ãƒå¾Œã¯ãƒ„ãƒ¢ç‰Œï¼ˆæœ€å¾Œã®ç‰Œï¼‰ã®ã¿æœ‰åŠ¹ã«
          const lastTileIndex = convertMPSZToPaiIndex(currentHandString.slice(-2));
          const isLastTile = index === lastTileIndex;
          img.style.pointerEvents = isLastTile ? 'auto' : 'none';
          img.style.opacity = isLastTile ? '1.0' : '0.5';
          return;
        }

        if (isRiichi) {
          img.style.pointerEvents = tingpaiSet.has(index) ? 'auto' : 'none';
          img.style.opacity = tingpaiSet.has(index) ? '1.0' : '0.5';
        } else {
          img.style.pointerEvents = 'auto';
          img.style.opacity = '1.0';
        }
      });
    }

    // ãƒªãƒ¼ãƒãƒœã‚¿ãƒ³æŠ¼ä¸‹
    riichiButton.onclick = () => {
      isRiichi = true;
      riichiButton.style.display = 'none';
      canselButton.style.display = 'inline-block';

      // Set ã«å¤‰æ›ã—ã¦ãŠã
      tingpaiSet = new Set(tingpaiList);
      console.log('ãƒªãƒ¼ãƒå¯èƒ½ç‰Œ:', [...tingpaiSet]);

      // æœ‰åŠ¹ãªç‰Œã ã‘ã‚¯ãƒªãƒƒã‚¯å¯èƒ½ã«ã™ã‚‹
      document.querySelectorAll('.tile').forEach(img => {
        const idx = parseInt(img.dataset.index, 10);

        if (tingpaiSet.has(idx)) {
          img.style.pointerEvents = 'auto';
          img.style.opacity = '1.0';
          img.classList.remove('disabled');
        } else {
          img.style.pointerEvents = 'none';
          img.style.opacity = '0.5';
          img.classList.add('disabled');
        }
      });
    };

    // ã‚­ãƒ£ãƒ³ã‚»ãƒ«
    // ã‚­ãƒ£ãƒ³ã‚»ãƒ«æ™‚ã®å‡¦ç†
    canselButton.onclick = () => {
      isRiichi = false;
      canselButton.style.display = 'none';
      riichiButton.style.display = 'inline-block';

      // å…¨ç‰Œã‚’å†ã³æœ‰åŠ¹ã«æˆ»ã™
      document.querySelectorAll('.tile').forEach(img => {
        img.style.pointerEvents = 'auto';
        img.style.opacity = '1.0';
        img.classList.remove('disabled');
      });
    }


    ronButton.onclick = () => {
      if (ronPendingPai !== null) {
        ws.send(JSON.stringify({
          type: 'ron',
          roomId: myRoomId,
          playerIndex: myPlayerIndex,
          pai: ronPendingPai
        }));
        ronPendingPai = null;
      }
      hideRonSkipButtons();
    };

    tsumoButton.onclick = () => {
      tsumoButton.style.display = 'none';
      tsumoskipButton.style.display = 'none';

      ws.send(JSON.stringify({
        type: 'tsumo',
        roomId: myRoomId,
        playerIndex: myPlayerIndex
      }));
    };

    tsumoskipButton.onclick = () => {
      tsumoButton.style.display = 'none';
      tsumoskipButton.style.display = 'none';

      // ãƒ„ãƒ¢ã‚¹ã‚­ãƒƒãƒ— â†’ é€šå¸¸ã®æ‰“ç‰Œã«ç§»è¡Œ
      canDiscard = true;
    };

    // ã‚¹ã‚­ãƒƒãƒ—ã‚’æŠ¼ã—ãŸå ´åˆ
    skipButton.onclick = () => {
      hideRonSkipButtons();
      ws.send(JSON.stringify({
        type: 'skip',
        roomId: myRoomId,
        playerIndex: myPlayerIndex
      }));
      ronPendingPai = null;
    };

    function showHandFromShoupaiString(handStr) {
      currentHandString = handStr;
      console.log("ğŸ€„ å†æç”»å¯¾è±¡ã®æ‰‹ç‰Œ:", handStr);
      handDiv.innerHTML = '';
      let suit = '';

      for (let i = 0; i < handStr.length; i++) {
        const ch = handStr[i];
        if ('mpsz'.includes(ch)) {
          suit = ch;
        } else if (/\d/.test(ch)) {
          const tileStr = `${suit}${ch}`;
          const img = document.createElement('img');
          img.src = `/dist/image/${suit}${ch}.gif`;
          img.alt = tileStr;
          img.style.width = '5vw';
          img.style.margin = '2px';
          img.style.cursor = 'pointer';

          img.classList.add('tile');
          img.dataset.index = convertMPSZToPaiIndex(tileStr);

          img.onclick = () => {
            console.log("ã‚¯ãƒªãƒƒã‚¯ã•ã‚Œã¾ã—ãŸ");
            if (!canDiscard) return;
            canDiscard = false;
            if (isRiichi) { //isRiichi=trueçŠ¶æ…‹ã§ç‰ŒãŒæ¨ã¦ã‚‰ã‚ŒãŸ=ãƒªãƒ¼ãƒæˆç«‹
              reached = true;
            }
            riichiButton.style.display = 'none'; //ç›¸æ‰‹ã®æ‰‹ç•ªã«ãªã‚‹ã‹ã‚‰ãƒœã‚¿ãƒ³ã‘ã™
            canselButton.style.display = 'none'; //ãƒªãƒ¼ãƒå¾Œã«ã‚­ãƒ£ãƒ³ã‚»ãƒ«ãƒœã‚¿ãƒ³ã‚’æ¶ˆã™

            const paiIndex = convertMPSZToPaiIndex(tileStr);

            img.remove(); //åŠé€æ˜ã®æ¨ã¦ç‰Œã‚‚ã†ã„ã‚‰ãªãã­ï¼Ÿ

            ws.send(JSON.stringify({
              type: 'dahai',
              roomId: myRoomId,
              playerIndex: myPlayerIndex,
              pai: paiIndex,
              isRiichi: reached
            }));
          };
          handDiv.appendChild(img);
        }
      }
      updateTileInteractivity();
    }

    function getTileImage(paiNumber) {
      const typeIndex = Math.floor(paiNumber / 4);
      if (typeIndex < 9) return `m${typeIndex + 1}.gif`;
      if (typeIndex < 18) return `p${typeIndex - 9 + 1}.gif`;
      if (typeIndex < 27) return `s${typeIndex - 18 + 1}.gif`;
      return `z${typeIndex - 27 + 1}.gif`;
    }

    function showOpponentDiscardedTile(pai, isRiichi = false) {
      if (opponentDiscards.children.length === 0) {
        opponentDiscards.innerHTML = '';
      }
      const img = document.createElement('img');
      img.src = `/dist/image/${getTileImage(pai)}`;
      img.alt = `${pai}`;
      img.style.width = '5vw';
      img.style.margin = '2px';
      if (isRiichi) {
        img.style.transform = 'rotate(90deg)';
        img.style.transformOrigin = 'center center';
      }
      opponentDiscards.appendChild(img);
    }

    function showMyDiscardedTile(pai, isRiichi = false) {
      if (myDiscards.children.length === 0) {
        myDiscards.innerHTML = '';
      }
      const img = document.createElement('img');
      img.src = `/dist/image/${getTileImage(pai)}`;
      img.alt = `${pai}`;
      img.style.width = '5vw';
      img.style.margin = '2px';
      if (isRiichi) {
        img.style.transform = 'rotate(90deg)';
        img.style.transformOrigin = 'center center';
      }
      myDiscards.appendChild(img);
    }

    ws.onclose = () => {
      statusDiv.textContent = 'ã‚µãƒ¼ãƒãƒ¼ã¨ã®æ¥ç¶šãŒåˆ‡æ–­ã•ã‚Œã¾ã—ãŸã€‚';
    };

    function convertMPSZToPaiIndex(paiStr) {
      const num = parseInt(paiStr[1]);
      const suit = paiStr[0];
      let base = 0;
      if (suit === 'p') base = 9;
      else if (suit === 's') base = 18;
      else if (suit === 'z') base = 27;
      const tileIndex = base + num - 1;
      return tileIndex * 4; // å¸¸ã«0ç•ªç›®ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
    }

    function convertIndexToMPSZ(index) {
      const tile = Math.floor(index / 4);  // 0ã€œ33 ã®ç‰Œç•ªå·
      const num = (tile % 9) + 1;
      const suitIndex = Math.floor(tile / 9);

      const suits = ['m', 'p', 's', 'z'];
      const suit = suits[suitIndex];

      return `${suit}${num}`;
    }

    function updateScoreDisplay(newScores) {
      // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æ•°ã ã‘ãƒ«ãƒ¼ãƒ—ï¼ˆä»Šå›ã¯2äººç”¨ï¼‰
      newScores.forEach((score, index) => {
        const scoreElement = document.getElementById(`score-${index}`);
        if (scoreElement) {
          scoreElement.textContent = score;
        } else {
          console.warn(`ã‚¹ã‚³ã‚¢è¡¨ç¤ºè¦ç´  score-${index} ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“`);
        }
      });
    }

    function showResultModal(text, callback) {
      const modal = document.getElementById('resultModal');
      const resultText = document.getElementById('resultText');
      const okBtn = document.getElementById('modalOkBtn');

      resultText.textContent = text;
      modal.style.display = 'flex';

      function onClose() {
        modal.style.display = 'none';
        okBtn.removeEventListener('click', onClose);
        if (callback) callback();
      }
      okBtn.addEventListener('click', onClose);
    }
  </script>
</body>

</html>